"""
Santa Claus has a big job every Christmas: he needs to deliver gifts to all the good children around the world. 
But this year, the Holly Bureau says Santa must be extra careful with his travel. 
He needs to find the shortest way to visit every child and still make it back to the North Pole in time. 
Imagine Santa looking at a big map, trying to pick the best path. 
He must think hard to make sure he doesn't fly too far or miss any houses. 
It's like a fun puzzle for Santa, where he must plan his trip smartly to make everyone happy on Christmas morning.

This scenario is an exact representation of a famous conundrum in operations research and computer science known as the Traveling Salesman Problem, or TSP. 
The TSP asks for the shortest possible route that visits a set of locations and then returns to the starting point. 
It sounds deceptively simple, yet it's incredibly challenging, especially as the number of locations increases. 
This problem has a broad range of applications, from logistics and route planning to fields as diverse as DNA sequencing and the arrangement of computer chips.

"""
import array
import random
import json

import numpy
import networkx as nx
import matplotlib.pyplot as plt

from deap import algorithms
from deap import base
from deap import creator
from deap import tools

import os
from pathlib import Path


script_dir = os.path.dirname(os.path.realpath(__file__))

# santaDistance*.json contains the distance map in list of list style in JSON format
json_path = os.path.join(script_dir, "../data/santaDistance01.json")

with open(json_path, "r") as tsp_data:
    distance_map = json.load(tsp_data)

POPULATION_SIZE = 300
HALL_OF_FAME_SIZE = 1
P_MUTATION = 0.5
P_CROSSOVER = 0.3
MAX_GENERATIONS = 200
TOURNSIZE = 3
INDPB = 0.05
RANDOM_SEED = 42
IND_SIZE = len(distance_map)

"""
creator

The :mod:`~deap.creator` is a meta-factory allowing to create classes that
will fulfill the needs of your evolutionary algorithms. In effect, new
classes can be built from any imaginable type, from :class:`list` to
:class:`set`, :class:`dict`, :class:`~deap.gp.PrimitiveTree` and more,
providing the possibility to implement genetic algorithms, genetic
program"""

#single objective minimizing fitness named FitnessMin.
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

#An invidual descritpion what equvalent of a chromosome. Each element ong array is a gene.
creator.create("Individual", array.array, typecode='i', fitness=creator.FitnessMin)

#A toolbox for evolution that contains the evolutionary operators.
toolbox = base.Toolbox()

# Attribute generator
# It sets up a mechanism to generate an array of length IND_SIZE filled with random numbers from a given range (in this case, from 0 to IND_SIZE - 1).
toolbox.register("indices", random.sample, range(IND_SIZE), IND_SIZE)

# Structure initializers
#initIterate is a factory method used to create new individuals in the population. It's designed to repeatedly apply a given function (in this case, toolbox.indices) to generate a new object.
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.indices)

#The initRepeat function is a factory method used to create a container filled with content generated by repeatedly calling another function. 
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

#the fitness function
def evalTSP(individual):
    #It's an array contains integers
    individual_last = individual[-1] #last element
    individual_first = individual[0] #first element
    
    distance = distance_map[individual_last][individual_first] #distance between the last and first becasuse Santa have to back to nort pole
    
    for gene1, gene2 in zip(individual[0:-1], individual[1:]): #loop throught in the all way
        distance += distance_map[gene1][gene2]
    return distance, #return distance the smaller the better

#Executes a partially matched crossover (PMX) on the input individuals. The two individuals are modified in place.
#This method is commonly used in permutation-based problems, where each gene must be unique and should appear exactly once in the chromosome.
toolbox.register("mate", tools.cxPartialyMatched)


#The mutShuffleIndexes function is designed for mutation in permutation-based problems. 
#What this function does is it shuffles the indices (genes) of the individual, but in a controlled manner.
#indpb=0.05: This is the independent probability of each attribute (gene) to be mutated. 
# In this case, indpb is set to 0.05, which means that each gene in the individual has a 5% chance of being mutated (shuffled).
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=INDPB)

#A group of individuals is randomly selected from the population. The size of this group is determined by tournsize.
#The winner of this tournament is typically the individual with the highest fitness (for maximization problems) or lowest fitness (for minimization problems), 
#depending on how fitness is defined in your problem.
toolbox.register("select", tools.selTournament, tournsize=TOURNSIZE)

toolbox.register("evaluate", evalTSP)

def main():
    random.seed(RANDOM_SEED)

    pop = toolbox.population(n=POPULATION_SIZE)

    hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("std", numpy.std)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)



    algorithms.eaSimple(pop, toolbox, P_CROSSOVER, P_MUTATION, MAX_GENERATIONS, stats=stats, 
                        halloffame=hof)

    return pop, stats, hof

def display(distance_matrix, optimal_path):
    matrix = numpy.array(distance_matrix)

    # Create a directed graph
    G = nx.DiGraph()

    # Add edges to the graph (with distance as weight)
    for i in range(len(matrix)):
        for j in range(i+1, len(matrix)):
            G.add_edge(i, j, weight=matrix[i][j])
            G.add_edge(j, i, weight=matrix[j][i])  # Add the reverse edge for a complete graph

    # Specify the layout for your nodes
    pos = nx.spring_layout(G)

    # Draw the graph with all edges
    nx.draw(G, pos, with_labels=True, node_color='lightblue', 
            node_size=500, font_size=10, font_weight='bold', arrowsize=20)

    # Draw the optimal path with a different color and width
    for i in range(len(optimal_path)-1):
        nx.draw_networkx_edges(G, pos, edgelist=[(optimal_path[i], optimal_path[i+1])], 
                            width=2, edge_color='red', arrows=True)

    plt.title("Directed Graph Representation with Optimal Path")
    plt.show()
    
if __name__ == "__main__":
    res=main()
    best_individual = tools.selBest(res[2], 1)[0]
    print("Best Individual:", best_individual)
    print("Total Distance:", evalTSP(best_individual)[0])
    
    display(distance_map, best_individual)