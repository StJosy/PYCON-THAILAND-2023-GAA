"""
Santa Claus has a big job every Christmas: he needs to deliver gifts to all the good children around the world. 
But this year, the Holly Bureau says Santa must be extra careful with his travel. 
He needs to find the shortest way to visit every child and still make it back to the North Pole in time. 
Imagine Santa looking at a big map, trying to pick the best path. 
He must think hard to make sure he doesn't fly too far or miss any houses. 
It's like a fun puzzle for Santa, where he must plan his trip smartly to make everyone happy on Christmas morning.

This scenario is an exact representation of a famous conundrum in operations research and computer science known as the Traveling Salesman Problem, or TSP. 
The TSP asks for the shortest possible route that visits a set of locations and then returns to the starting point. 
It sounds deceptively simple, yet it's incredibly challenging, especially as the number of locations increases. 
This problem has a broad range of applications, from logistics and route planning to fields as diverse as DNA sequencing and the arrangement of computer chips.

"""
import array
import random
import json

import numpy
import networkx as nx
import matplotlib.pyplot as plt

from deap import algorithms
from deap import base
from deap import creator
from deap import tools

import os
from pathlib import Path

script_dir = os.path.dirname(os.path.realpath(__file__))

# santaDistance*.json contains the distance map in list of list style in JSON format
#json_path = os.path.join(script_dir, "../data/santaDistance01.json")
json_path = os.path.join(script_dir, "../data/th.json")

with open(json_path, "r") as tsp_data:
    distance_map = json.load(tsp_data)

POPULATION_SIZE = 300
HALL_OF_FAME_SIZE = 1
P_MUTATION = 0.5
P_CROSSOVER = 0.3
MAX_GENERATIONS = 100
TOURNSIZE = 3
INDPB = 0.05
RANDOM_SEED = 42
IND_SIZE = len(distance_map)
#the fitness function
#The fitness evaluation function should be adjusted to start from the fixed city (index 0) and then follow the permutation of the other cities
def evalTSP(individual):
    distance = 0
    # Iterate over the cities in the individual's permutation
    for i in range(1, len(individual)):
        distance += distance_map[individual[i-1]][individual[i]]

    # Add the distance from the last city back to the North Pole
    distance += distance_map[individual[-1]][0]

    return distance,

def customMutation(individual):
    # Choose two indices to swap, ensuring they are not the starting city
    index1 = random.randint(1, len(individual) - 1)
    index2 = random.randint(1, len(individual) - 1)
    while index1 == index2:
        index2 = random.randint(1, len(individual) - 1)
    
    # Swap the two cities
    individual[index1], individual[index2] = individual[index2], individual[index1]
    return individual,

def main():

    """
    creator

    The :mod:`~deap.creator` is a meta-factory allowing to create classes that
    will fulfill the needs of your evolutionary algorithms. In effect, new
    classes can be built from any imaginable type, from :class:`list` to
    :class:`set`, :class:`dict`, :class:`~deap.gp.PrimitiveTree` and more,
    providing the possibility to implement genetic algorithms, genetic
    program"""

    #single objective minimizing fitness named FitnessMin.
    creator.create("FitnessMin", base.Fitness, weights=(-1.0,))

    #An invidual descritpion what equvalent of a chromosome. Each element (int) in array is a gene .
    creator.create("Individual", array.array, typecode='i', fitness=creator.FitnessMin)

    #A toolbox for evolution that contains the evolutionary operators.
    toolbox = base.Toolbox()

    # Attribute generator
    # It sets up a mechanism to generate an array of length IND_SIZE filled with random numbers from a given range (in this case, from 0 to IND_SIZE - 1).
    # Adjust the range to exclude the starting city (assuming it's at index 0)
    toolbox.register("indices", random.sample, range(1, IND_SIZE), IND_SIZE - 1)
    
    # Structure initializers
    #initIterate is a factory method used to create new individuals in the population. It's designed to repeatedly apply a given function (in this case, toolbox.indices) to generate a new object.
    # When creating an individual, prepend the starting city (index 0)
    toolbox.register("individual", tools.initIterate, creator.Individual, lambda: [0] + toolbox.indices())

    #The initRepeat function is a factory method used to create a container filled with content generated by repeatedly calling another function. 
    toolbox.register("population", tools.initRepeat, list, toolbox.individual)



    #Executes a partially matched crossover (PMX) on the input individuals. The two individuals are modified in place.
    #This method is commonly used in permutation-based problems, where each gene must be unique and should appear exactly once in the chromosome.
    toolbox.register("mate", tools.cxPartialyMatched)


    
    toolbox.register("mutate", customMutation)

    #A group of individuals is randomly selected from the population. The size of this group is determined by tournsize.
    #The winner of this tournament is typically the individual with the highest fitness (for maximization problems) or lowest fitness (for minimization problems), 
    #depending on how fitness is defined in your problem.
    toolbox.register("select", tools.selTournament, tournsize=TOURNSIZE)

    toolbox.register("evaluate", evalTSP)


    #random.seed(RANDOM_SEED)

    pop = toolbox.population(n=POPULATION_SIZE)
    
    #The HallOfFame is a useful tool from the DEAP framework. 
    #It ensures that the best individual is preserved throughout the evolutionary process, even if the algorithm favors other solutions.
    hof = tools.HallOfFame(HALL_OF_FAME_SIZE)
    
    stats = tools.Statistics(lambda ind: ind.fitness.values)
    stats.register("avg", numpy.mean)
    stats.register("std", numpy.std)
    stats.register("min", numpy.min)
    stats.register("max", numpy.max)



    algorithms.eaSimple(pop, toolbox, P_CROSSOVER, P_MUTATION, MAX_GENERATIONS, stats=stats, 
                        halloffame=hof)

    return pop, stats, hof

def display(distance_matrix, optimal_path):
    matrix = numpy.array(distance_matrix)

    # Create a directed graph
    G = nx.DiGraph()

    # Add edges to the graph (with distance as weight)
    for i in range(len(matrix)):
        for j in range(i+1, len(matrix)):
            G.add_edge(i, j, weight=matrix[i][j])
            G.add_edge(j, i, weight=matrix[j][i])  # Add the reverse edge for a complete graph

    # Specify the layout for your nodes
    pos = nx.spring_layout(G)

    # Draw the graph with all edges
    nx.draw(G, pos, with_labels=True, node_color='lightblue', 
            node_size=500, font_size=10, font_weight='bold', arrowsize=20)

    # Draw the optimal path with a different color and width
    for i in range(len(optimal_path)-1):
        nx.draw_networkx_edges(G, pos, edgelist=[(optimal_path[i], optimal_path[i+1])], 
                            width=2, edge_color='red', arrows=True)

    plt.title("Directed Graph Representation with Optimal Path")
    plt.show()
    
if __name__ == "__main__":
    res=main()
    #best_individual = tools.selBest(res[2], 1)[0]
    best_individual = res[2][0]
    print("Best Individual:", best_individual)
    print("Total Distance:", evalTSP(best_individual)[0])

    complete_route = list(best_individual) + [0]
    print("Complete Route:", complete_route)
    
    display(distance_map, complete_route)